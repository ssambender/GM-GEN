<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gerrymandle Map Editor</title>
  <link rel="icon" href="https://raw.githubusercontent.com/ssambender/GM-GEN/refs/heads/main/G-Edit-Logo.png">
  <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/ssambender/GM-GEN/refs/heads/main/G-Edit-Logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap');

    body {
      margin: 0;
      background: #fff;
      font-size: 1em;
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #333333;
    }

    #heading {
      border-bottom: solid 1px #e8e8e8;
      width: 100%;
      text-align: center;
      padding: 14px 0 4px 0;
      margin-bottom: 16px;
      font-size: 2em;
      text-transform: uppercase;
    }

    .group-inputs, .seed-input {
      font-size: 18px;
      margin-bottom: 10px;
    }
    input {
      padding: 0;
      font-size: 1em;
      text-align: center;
      margin: 0 4px;
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      color: #333333;

      width: 2em;
    }
    #seedInput {
      width: 5em;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(6, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 5px;
      margin-bottom: 10px;
    }
    .cell {
      width: 50px;
      height: 50px;
      background-color: white;
      border: 1px solid #ccc;
      transition: background-color 0.2s ease;
      touch-action: manipulation;
      border-radius: 50%;
    }
    .buttons {
      margin-bottom: 10px;
    }
    button {
      margin: 5px;
      padding: 4px 12px;
      font-size: 1.2em;
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      color: #333333;
      border: none;
      cursor: pointer;
      transition: .15s;
    }
    button:hover {
      background-color: #d0d5d9;
    }
    .counter {
      margin-bottom: 5px;
      font-size: 1.2em;
    }
    .counter span {
      font-weight: bold;
    }
    .counter .red,
    #mismatchMessage .red {
      color: #e05353;
    }
    .counter .blue,
    #mismatchMessage .blue {
      color: #5988d1;
    }
    #mismatchMessage {
      font-size: 1.2em;
      display: none;
      font-weight: bold;
    }
    textarea {
      margin-top: 10px;
      width: 90%;
      max-width: 500px;
      height: 220px;
      font-family: monospace;
      font-size: 14px;
    }
    label {
      font-size: 1.25em;
    }
    a {
      color: #55698c;
    }
    a:hover {
      color: #2a87ff;
    }
  </style>
</head>
<body>
<div id="heading">
  ✰✰✰ Gerrymandle Map Editor ✰✰✰
</div>

<div style="margin-bottom: 16px; text-align: center; line-height: 1; font-size: 1.1em; padding: 16px 0">
  This editor can be used to create, edit, and share maps for <a href="https://ssambender.github.io/gerrymandle/">Gerrymandle</a>.<br>
  Create a map either manually, by clicking a tile to toggle through <span style="color: #e05353;">RED</span>/<span style="color: #5988d1;">BLUE</span>/<span style="color:gray;">GRAY</span>/OFF.<br>
  Or, enter a random generation seed to procedurally attempt to create a unique and solvable level.
</div>

<div class="group-inputs">
  <label>
    <input type="number" id="groupCount" value="5" min="1" max="24" /> groups of
    <input type="number" id="groupSize" value="6" min="1" max="24" />
  </label>
</div>
<div class="seed-input">
  <label>Seed: <input type="text" id="seedInput" value="080525" placeholder="[none]" /></label>
  <!--                                        starting seed value  -->
  <button onclick="generateFromSeed()">Generate from Seed</button>
</div>
<div class="grid" id="grid"></div>
<div id="mismatchMessage"></div>
<div class="counter" id="counter">
  <span class="red">Red: 0</span> | <span class="blue">Blue: 0</span>
</div>
<div class="buttons">
  <button onclick="resetGrid()">Reset</button>
  <button onclick="convertToText()">Convert to Text</button>
  <button onclick="copyLevelURL()">Copy Direct URL</button>
  <button onclick="goToURL()">TRY OUT (new tab)</button>
</div>

<div id="copyMessage" style="height: 24px; font-size: 1em; font-weight: bold; color: #55698c;"></div>

<script>
  const COLORS = ['white', '#e05353', '#5988d1', '#dadada'];
  const SYMBOLS = {'white': ' ', '#e05353': 'R', '#5988d1': 'B', '#dadada': 'O'};
  const rows = 8, cols = 6;
  let copyMessageTimeout = null;

  const today = new Date();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  const year = String(today.getFullYear()).slice(-2);
  const formatted = `${month}${day}${year}`;
  document.getElementById('seedInput').value = formatted;

  function createGrid() {
    const grid = document.getElementById('grid');
    grid.innerHTML = '';
    for (let i = 0; i < rows * cols; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.colorIndex = 0;
      cell.style.backgroundColor = COLORS[0];
      cell.addEventListener('click', () => {
        let index = parseInt(cell.dataset.colorIndex);
        index = (index + 1) % COLORS.length;
        cell.dataset.colorIndex = index;
        cell.style.backgroundColor = COLORS[index];
        updateCounter();
      });
      grid.appendChild(cell);
    }
  }

  function resetGrid() {
    document.querySelectorAll('.cell').forEach(cell => {
      cell.dataset.colorIndex = 0;
      cell.style.backgroundColor = COLORS[0];
    });
    updateCounter();
  }

  function convertToText() {
    const groupCount = document.getElementById('groupCount').value;
    const groupSize = document.getElementById('groupSize').value;
    const cells = document.querySelectorAll('.cell');

    const seed = document.getElementById('seedInput').value.trim();
    const levelLabel = seed ? `'${seed}':` : 'LVL00:';

    let outputLines = [`${levelLabel} ["${groupCount}", "${groupSize}",`];

    let rowArray = [];
    cells.forEach((cell, index) => {
      const mapped = SYMBOLS[COLORS[parseInt(cell.dataset.colorIndex)]];
      rowArray.push(`"${mapped}"`);
      if ((index + 1) % cols === 0) {
        outputLines.push('    ' + rowArray.join(', ') + ',');
        rowArray = [];
      }
    });

    outputLines.push('],');
    const finalText = outputLines.join('\n');

    navigator.clipboard.writeText(finalText)
            .then(() => showCopyMessage("Level text successfully copied"))
            .catch(err => alert("Failed to copy level text: " + err));
  }

  function updateCounter() {
    const cells = document.querySelectorAll('.cell');
    let red = 0, blue = 0;
    cells.forEach(cell => {
      const color = COLORS[parseInt(cell.dataset.colorIndex)];
      if (color === '#e05353') red++;
      else if (color === '#5988d1') blue++;
    });
    document.getElementById('counter').innerHTML = `<span class="red">Red: ${red}</span> | <span class="blue">Blue: ${blue}</span>`;
    const groupCount = parseInt(document.getElementById('groupCount').value) || 0;
    const groupSize = parseInt(document.getElementById('groupSize').value) || 0;
    const totalVotes = groupCount * groupSize;
    const totalSelected = red + blue;
    const mismatch = document.getElementById('mismatchMessage');
    if (totalSelected !== totalVotes) {
      mismatch.style.display = 'block';
      mismatch.innerHTML = `(<span class="red">${red}</span> + <span class="blue">${blue}</span> !== ${totalVotes})`;
    } else mismatch.style.display = 'none';
  }

  function sha256(text) {
    const utf8 = new TextEncoder().encode(text);
    return crypto.subtle.digest('SHA-256', utf8).then(buf => {
      return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
    });
  }

  function mulberry32(seed) {
    return function () {
      seed |= 0; seed = seed + 0x6D2B79F5 | 0;
      let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  function numberToSuffix(n) {
    let s = '';
    while (n >= 0) {
      s = String.fromCharCode((n % 26) + 97) + s;
      n = Math.floor(n / 26) - 1;
    }
    return s;
  }

  async function generateFromSeed() {
    const baseSeed = document.getElementById('seedInput').value.trim();
    if (!baseSeed) return alert('Enter text in seed input field.');

    //const combos = [ [5,6], [6,5], [7,3], [4,7], [3,8], [6,4], [5,5], [5,5], [5,3], [5,3], [5,3], [5,4] ];
    const combos = [ [5,6], [6,5], [7,3], [4,7], [3,8], [6,4], [5,5], [5,3], [5,4] ];

    let attempt = 0;
    let finalSeed = "";

    while (true) {
      const suffix = attempt === 0 ? '' : numberToSuffix(attempt - 1);
      const fullSeed = baseSeed + suffix;

      const hash = await sha256(fullSeed);
      const seed = parseInt(hash.slice(0, 8), 16);
      const rand = mulberry32(seed);
      const comboIndex = parseInt(hash.slice(8, 10), 16) % combos.length;
      const [groupCount, groupSize] = combos[comboIndex];

      const level = generateWinnableLevel(groupCount, groupSize, rand, 0);
      if (level) {
        finalSeed = fullSeed;
        // if success populate ui
        document.getElementById('groupCount').value = groupCount;
        document.getElementById('groupSize').value = groupSize;

        const cells = document.querySelectorAll('.cell');
        for (let i = 0; i < level.length - 2; i++) {
          const char = level[i + 2];
          let colorIndex = 0;
          if (char === 'R') colorIndex = 1;
          else if (char === 'B') colorIndex = 2;
          else if (char === 'O') colorIndex = 3;
          const cell = cells[i];
          cell.dataset.colorIndex = colorIndex;
          cell.style.backgroundColor = COLORS[colorIndex];
        }

        // Show the actual seed used
        document.getElementById('seedInput').value = finalSeed;
        updateCounter();
        return;
      }

      attempt++;
    }
  }

  function generateWinnableLevel(districtCount, voteCount, rand) {
    const grid = Array.from({ length: rows }, () => Array(cols).fill(" "));
    const used = Array.from({ length: rows }, () => Array(cols).fill(false));
    const districts = [];

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function getNeighbors(r, c) {
      return [[r-1,c], [r+1,c], [r,c-1], [r,c+1]].filter(([nr,nc]) => nr>=0 && nr<rows && nc>=0 && nc<cols && !used[nr][nc]);
    }

    function placeDistrict() {
      let attempts = 0;
      while (attempts++ < 3000) {
        const startR = Math.floor(rand() * rows);
        const startC = Math.floor(rand() * cols);
        if (used[startR][startC]) continue;
        const queue = [[[startR, startC]]];
        while (queue.length) {
          const path = queue.shift();
          if (path.length >= voteCount) {
            const finalPath = path.slice(0, voteCount);
            finalPath.forEach(([r,c]) => used[r][c] = true);
            const oTiles = [];
            for (let i = voteCount; i < Math.min(path.length, voteCount + 2); i++) {
              const [r,c] = path[i];
              if (!used[r][c]) {
                used[r][c] = true;
                oTiles.push([r,c]);
              }
            }
            districts.push({ path: finalPath, oTiles, votes: [] });
            return true;
          }
          const [lr,lc] = path[path.length - 1];
          const neighbors = getNeighbors(lr,lc).filter(([nr,nc]) => !path.some(([pr,pc]) => pr===nr && pc===nc));
          shuffle(neighbors);
          neighbors.forEach(n => queue.push([...path, n]));
        }
      }
      return false;
    }

    for (let i = 0; i < districtCount; i++) {
      if (!placeDistrict()) return null; // return null on failure
    }

    let redWins = 0, blueWins = 0, redTiles = 0, blueTiles = 0;

    for (const dist of districts) {
      let r = 0, b = 0;
      const votes = [];

      for (let i = 0; i < dist.path.length; i++) {
        const vote = rand() < 0.48 ? 'R' : 'B';
        vote === 'R' ? r++ : b++;
        votes.push(vote);
      }

      // Force red win if needed
      if (r <= b) {
        for (let i = 0; i < votes.length; i++) {
          if (votes[i] === 'B') {
            votes[i] = 'R';
            r++; b--;
            break;
          }
        }
      }

      dist.votes = votes;
      redTiles += r;
      blueTiles += b;
      if (r > b) redWins++;
      else if (b > r) blueWins++;
    }

    //return null if not a winnable layout
    if (redWins <= blueWins || redTiles >= blueTiles) return null;

    for (const dist of districts) {
      dist.path.forEach(([r, c], i) => grid[r][c] = dist.votes[i]);
      dist.oTiles.forEach(([r, c]) => grid[r][c] = 'O');
    }

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (grid[r][c] === ' ') grid[r][c] = rand() < 0.3 ? 'O' : ' ';
      }
    }

    return [districtCount.toString(), voteCount.toString(), ...grid.flat()];
  }

  function copyLevelURL() {
    const groupCount = document.getElementById('groupCount').value;
    const groupSize = document.getElementById('groupSize').value;
    const cells = document.querySelectorAll('.cell');

    let raw = groupCount + groupSize;
    cells.forEach(cell => {
      const color = COLORS[parseInt(cell.dataset.colorIndex)];
      let char = SYMBOLS[color];
      raw += char === ' ' ? 'X' : char;
    });

    const finalURL = `https://ssambender.github.io/gerrymandle?level=${raw}`;

    navigator.clipboard.writeText(finalURL)
            .then(() => showCopyMessage("Level URL successfully copied"))
            .catch(err => alert("Failed to copy URL: " + err));
  }

  function showCopyMessage(text) {
    const msg = document.getElementById('copyMessage');
    msg.textContent = text;

    if (copyMessageTimeout) {
      clearTimeout(copyMessageTimeout);
    }

    copyMessageTimeout = setTimeout(() => {
      msg.textContent = '';
      copyMessageTimeout = null;
    }, 1000);
  }

  function goToURL() {
    const groupCount = document.getElementById('groupCount').value;
    const groupSize = document.getElementById('groupSize').value;
    const cells = document.querySelectorAll('.cell');

    let raw = groupCount + groupSize;
    cells.forEach(cell => {
      const color = COLORS[parseInt(cell.dataset.colorIndex)];
      let char = SYMBOLS[color];
      raw += char === ' ' ? 'X' : char;
    });

    const finalURL = `https://ssambender.github.io/gerrymandle?level=${raw}`;
    window.open(finalURL, '_blank');
  }

  createGrid();
  updateCounter();
  document.getElementById('groupCount').addEventListener('input', updateCounter);
  document.getElementById('groupSize').addEventListener('input', updateCounter);
</script>
</body>
</html>
